package com.ericsson.fmt.forecasting.engine.impl;

import java.util.List;

import weka.classifiers.timeseries.eval.TSEvalModule;
import weka.classifiers.timeseries.eval.TSEvaluation;
import weka.core.Instances;

public class FMTTSEvaluation extends TSEvaluation {
	
	public FMTTSEvaluation(Instances trainingData, double testSplitSize) throws Exception {
		super(trainingData, testSplitSize);
		
	}
	public FMTTSEvaluation(Instances trainingData, Instances testData) throws Exception {
		super(trainingData, testData);
		
	}

	public double getErrorOnTrainingData(String method){
		  double rms = 0.0;
		  int count = 0;
		  if(m_metricsForTrainingData != null && !m_metricsForTrainingData.isEmpty() && m_metricsForTrainingData.containsKey(method)){
			  //get the evaluation for each step
			  List<TSEvalModule> evalsForKey = m_metricsForTrainingData.get(method);
			  
			  if(evalsForKey != null){
				  for(TSEvalModule tsm : evalsForKey){
					  try {
						  double [] metrics = tsm.calculateMeasure();
						  rms += metrics[0];
						  count++;
					} catch (Exception e) {
						
					}
				  }
			  }
		  }
		  
		  return count > 0 ? rms/count : Double.NaN;
		  
	  }
	
	public double getErrorOnTestData(String method){
		  double rms = 0.0;
		  int count = 0;
		  if(m_metricsForTestData != null && !m_metricsForTestData.isEmpty() && m_metricsForTestData.containsKey(method)){
			  //get the evaluation for each step
			  List<TSEvalModule> evalsForKey = m_metricsForTestData.get(method);
			  
			  if(evalsForKey != null){
				  for(TSEvalModule tsm : evalsForKey){
					  try {
						  double [] metrics = tsm.calculateMeasure();
						  rms += metrics[0];
						  count++;
					} catch (Exception e) {
						
					}
				  }
			  }
		  }
		  
		  return count > 0 ? rms/count : Double.NaN;
		  
	  }
		
}
