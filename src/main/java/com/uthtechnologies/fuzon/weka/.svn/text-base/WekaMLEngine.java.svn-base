package com.ericsson.fmt.forecasting.engine.impl;

import java.math.BigDecimal;
import java.math.RoundingMode;

import org.apache.log4j.Logger;

import weka.classifiers.Classifier;
import weka.core.Instance;
import weka.core.Instances;

import com.ericsson.fmt.commons.Constants;
import com.ericsson.fmt.commons.PropertiesReader.ForecastEngineConfig;
import com.ericsson.fmt.forecasting.Forecast;
import com.ericsson.fmt.forecasting.dto.CPHFunction;
import com.ericsson.fmt.forecasting.engine.Context;
import com.ericsson.fmt.forecasting.engine.MLEngine;
import com.ericsson.fmt.forecasting.method.impl.WekaRegression;
import com.ericsson.fmt.forecasting.method.impl.WekaTimeSeries;
import com.ericsson.fmt.forecasting.utils.ForecastExecutionException;
import com.ericsson.fmt.forecasting.utils.Metrics;

public class WekaMLEngine implements MLEngine
{

	private static final Logger	log	= Logger.getLogger(WekaMLEngine.class);

	public WekaMLEngine()
	{
	}

	private void executeTimeseries(final Context options) throws ForecastExecutionException
	{
		WekaTimeSeries function = null;

		Forecast<Double> forecast = null;

		Classifier engine = WekaClassifierConfigReader
				.getConfiguredWekaClassifier(Constants.WEKA_F_TYPE_TIME_SERIES);
				
		Instances instances = WekaDataHandler.getAsTimeSeriesData(options.getTimeSeriesHistory(), ForecastEngineConfig.useTSDateField());

		log.debug("Input data: \n" + instances);
		if (engine != null)
		{
			// use a configured Weka model
			function = new WekaTimeSeries(instances,
					Constants.TIME_SERIES_DATA_ATTRIB,
					ForecastEngineConfig.getTimeSeriesForecastSize(),
					Constants.TIME_SERIES_DATETIME_ATTRIB);
			function.setAlgorithm(engine);
			function.setUseBestFit(false);
		}
		else
		{
			// use a Best fit model
			function = new WekaTimeSeries(instances,
					Constants.TIME_SERIES_DATA_ATTRIB,
					ForecastEngineConfig.getTimeSeriesForecastSize(),
					Constants.TIME_SERIES_DATETIME_ATTRIB);
			function.setUseBestFit(true);
		}

		try
		{
			forecast = function.execute();
		}
		catch (Exception e)
		{
			e.printStackTrace();
			throw new ForecastExecutionException(e);
		}
		
		options.setPrediction(forecast);
		
		if(options.isPrintResults())
		{
			int i=1;
			double aggr = 0.0;
			for (double d : forecast.getForecastedResult())
			{
				aggr += Math.abs(d);
				log.info("[TimeSeries #" +(i++)+ "]: " + Math.abs(d));
			}
			
			log.info("AGGREGATED VALUE: " + aggr);
		}
	}

	@Override
	public void doTimeSeries(final Context options)
			throws ForecastExecutionException
	{

		log.info("Start time series ...");
		executeTimeseries(options);
		log.info("End time series ...");

	}
	
	private void executeRegression(Context options) throws ForecastExecutionException
	{
		
		if(ForecastEngineConfig.buildModelOnly())
		{
			buildRegressionModel(options);
		}
		else
		{
			executeRegressionModel(options);
		}
		
	}
	
	private void printResult(Forecast<Double> forecast, Instances predictData, Context options)
	{

		Metrics metric = new Metrics();
		int i = 0;
		for (double d : forecast.getForecastedResult())
		{
			Instance input = predictData.get(i);
			
			BigDecimal bd = new BigDecimal(d);
			bd = bd.setScale(2, RoundingMode.HALF_UP);
			
			double dev = Math.abs(input.classValue() - bd.doubleValue()) / input.classValue();
			metric.add(dev);
			
			CPHFunction param = (CPHFunction) options.getPredictData().get(i);
			try
			{
				String fId = (String) param.lhsParamByName("siteId").getParamValue();
				String fName = (String) param.lhsParamByName("siteName").getParamValue();
				
				log.info("[Regression Result]:" + " FacId="+fId+" Site="+fName+" Actual="+input.classValue()+" Predicted=" + Math.abs(bd.doubleValue()) + " Deviation="+dev);
				
			}
			catch (Exception e)
			{
				log.info("[Regression Result]:" + " Actual="+input.classValue()+" Predicted=" + Math.abs(bd.doubleValue()) + " Deviation="+dev);
				
			}
			
			i++;
		}
		metric.calculateDerived();
		log.info("-: Deviation Metrics :-");
		log.info(metric);
	
	}
	
	
	private void executeRegressionModel(Context options) throws ForecastExecutionException
	{
		
		WekaRegression engine = null;
		
		engine = new WekaRegression(null);
		engine.setSerializedModel(ForecastEngineConfig.getCphModelFilePath());
		engine.setSaveModel(false);
		engine.setBuildClassifier(false);
		engine.setLoadFromDisk(true);
		
		if(options.getPredictData() == null || options.getPredictData().isEmpty())
		{
			throw new ForecastExecutionException("No data found to run regression model!");
		}
		Instances predictData = WekaDataHandler.getAsRegressionData(options.getPredictData(), false);

		engine.setPredictOnData(predictData);
		
		Forecast<Double> forecast = engine.execute();
		options.setPrediction(forecast);
		
		if (options.isPrintResults())
		{
			printResult(forecast, predictData, options);
		}
	}
	
	private void buildRegressionModel(Context options) throws ForecastExecutionException
	{
		Classifier classifier = null;

		boolean buildClassifier = true;
		WekaRegression engine = null;
		
		classifier = WekaClassifierConfigReader.getConfiguredWekaClassifier(Constants.WEKA_F_TYPE_REGRESSION);

		if (classifier == null)
		{

			buildClassifier = false;

		}
		engine = new WekaRegression(classifier);
		engine.setSerializedModel(ForecastEngineConfig.getCphModelFilePath());
		engine.setSaveModel(ForecastEngineConfig.saveClassifierModel());
		engine.setBuildClassifier(buildClassifier);
		engine.setMaxFolds(ForecastEngineConfig.getMaxCrossValidationFolds());
		engine.setCrossValidateWithTestData(ForecastEngineConfig.useTestDataForEvaluation());
		if(options.getTrainingData() == null || options.getTrainingData().isEmpty())
		{
			throw new ForecastExecutionException("No training data found to build regression model!");
		}
		if(options.getTestData() == null || options.getTestData().isEmpty())
		{
			throw new ForecastExecutionException("No test data found to build regression model!");
		}
		Instances trainData = WekaDataHandler.getAsRegressionData(options
				.getTrainingData(), true);
		Instances testData = WekaDataHandler.getAsRegressionData(options
				.getTestData(), true);
		
		engine.init(trainData, testData);
		engine.setPredictOnData(testData);
		
		Forecast<Double> forecast = engine.execute();
		options.setPrediction(forecast);
		
		if (options.isPrintResults())
		{
			printResult(forecast, testData, options);
		}
		
	}

	@Override
	public void doRegression(final Context opts)
			throws ForecastExecutionException
	{

		log.info("Begin regression ...");
		executeRegression(opts);
		log.info("End regression ...");

	}

	
}
