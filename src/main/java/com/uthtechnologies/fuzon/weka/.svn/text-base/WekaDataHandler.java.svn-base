package com.ericsson.fmt.forecasting.engine.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.math.NumberUtils;
import org.apache.log4j.Logger;

import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SparseInstance;

import com.ericsson.fmt.commons.Constants;
import com.ericsson.fmt.commons.Utilities;
import com.ericsson.fmt.forecasting.dto.CPHParam;
import com.ericsson.fmt.forecasting.dto.RegressionParam;
import com.ericsson.fmt.forecasting.dto.TimeseriesParam;
import com.ericsson.fmt.forecasting.utils.ForecastingUtil;


/**
 * TimeSeries DTO. Assuming time series data will be numeric only (double)
 * @author esutdal
 *
 */
public class WekaDataHandler{
	
	private static final Logger log = Logger.getLogger(WekaDataHandler.class);
	public WekaDataHandler() {
		// TODO Auto-generated constructor stub
	}
		
	Instances nextRegressionHistory(){
		return regressionHistory;
	}
	
	
	private Instances regressionHistory = null;
	
	/**
	 * 
	 * @param values
	 * @return
	 */
	public static List<Double> asList(Instances values){
		List<Double> list = null;
		if (values != null && !values.isEmpty()) {
			Attribute attribute = new Attribute(Constants.TIME_SERIES_DATA_ATTRIB);
			list = new ArrayList<Double>();
			Iterator<Instance> iter = values.iterator();
			while (iter.hasNext()) {
				
				list.add(iter.next().value(attribute));
			}
		}
		return list;
		
	}
		
	@SuppressWarnings("unused")
	private double [] getValues(List<Double> values){
		double [] arr = new double [0];
		if(values != null){
			arr = new double [values.size()];
			int i = 0;
			for(double value : values){
				arr[i++] = value;
			}
		}
		return arr;
	}
	
	private static Set<String> getStringCategories(List<? extends CPHParam> data, int index)
	{
		Set<String> set = new HashSet<>();
		for(CPHParam fun : data)
		{
			String string = String.valueOf(fun.getLhs().get(index).getParamValue());
			set.add(string);
		}
		return set;
		
	}
	private static Set<String> getStringCategories(List<? extends CPHParam> data)
	{
		Set<String> set = new HashSet<>();
		for(CPHParam fun : data)
		{
			String string = String.valueOf(fun.getRhs().getParamValue());
			set.add(string);
		}
		return set;
		
	}
	
	private static ArrayList<Attribute> makeAttributes(List<? extends CPHParam> input, boolean build)
	{
		CPHParam cphFun = input.get(0);
		ArrayList<Attribute> attributes = new ArrayList<Attribute>();
		Attribute attrib = null;
		int i=0;
		for(RegressionParam lhs : cphFun.getLhs())
		{
			if(!lhs.isParticipant())
			{
				i++;
				continue;
			}
			if (lhs.isCategory() && build)
			{
				Set<String> set = getStringCategories(input, i);
				List<String> list = new ArrayList<>(set.size());
				String[] tmp = set.toArray(new String[set.size()]);
				Collections.addAll(list, tmp);

				attrib = new Attribute(lhs.getParamName(), list);
			}
			else
			{
				if (NumberUtils.isNumber(String.valueOf(lhs.getParamValue())))
				{
					attrib = new Attribute(lhs.getParamName());
				}
				else if (!Utilities.isNullOrBlank(lhs.getDateFormat()))
				{
					attrib = new Attribute(lhs.getParamName(), lhs.getDateFormat());
				}
				else
				{
					List<String> empty = null;
					attrib = new Attribute(lhs.getParamName(), empty);
				}
			}
			
			attributes.add(attrib);
			i++;
		}
		
		if (cphFun.getRhs() != null)
		{
			if (cphFun.getRhs().isCategory() && build)
			{
				Set<String> set = getStringCategories(input);
				List<String> list = new ArrayList<>(set.size());
				String[] tmp = set.toArray(new String[set.size()]);
				Collections.addAll(list, tmp);

				attrib = new Attribute(cphFun.getRhs().getParamName(), list);
			}
			else
			{
				if (NumberUtils.isNumber(String.valueOf(cphFun.getRhs()
						.getParamValue())))
				{
					attrib = new Attribute(cphFun.getRhs().getParamName());
				}
				else if (!Utilities.isNullOrBlank(cphFun.getRhs()
						.getDateFormat()))
				{
					attrib = new Attribute(cphFun.getRhs().getParamName(),
							cphFun.getRhs().getDateFormat());
				}
				else
				{
					List<String> empty = null;
					attrib = new Attribute(cphFun.getRhs().getParamName(),
							empty);
				}
			}
			attributes.add(attrib);
		}
				
		return attributes;
	}
	/**
	 * 
	 * @param input
	 * @return
	 */
	public static Instances getAsRegressionData(List<? extends CPHParam> input, boolean build)
	{
		Instances instances = null;
		if(input.size() > 0)
		{
			
			ArrayList<Attribute> attributes = makeAttributes(input, build);
			
			instances = new Instances(Constants.REGRESSION_RELATION_NAME, attributes, input.size());
			Attribute attrib;
			
			attrib = attributes.get(attributes.size() - 1);
			instances.setClass(attrib);
			
			for(CPHParam func : input)
			{
				int attIndex = 0;
				Instance instance = new SparseInstance(attributes.size());
				for(RegressionParam lhs : func.getLhs())
				{
					if(!lhs.isParticipant())
					{
						continue;
					}
					attrib = attributes.get(attIndex);
					String stringValue = String.valueOf(lhs.getParamValue());
					if(attrib.isNumeric())
					{
						try
						{
							instance.setValue(attributes.get(attIndex++), Double.parseDouble(stringValue));
						}
						catch (NumberFormatException e)
						{
							log.error("Could not set numeric parameter value for attrib '"+attrib.name() +"' value- "+stringValue);
						}
					}
					else
					{
						instance.setValue(attributes.get(attIndex++), stringValue);
					}
				}
				attrib = attributes.get(attIndex);
				String stringValue = String.valueOf(func.getRhs()
						.getParamValue());
				if (attrib.isNumeric())
				{
					try
					{
						instance.setValue(attIndex++,
								Double.parseDouble(stringValue));
					}
					catch (NumberFormatException e)
					{
						log.error("Could not set numeric parameter value for attrib '"
								+ attrib.name() + "' value- " + stringValue);
					}
				}
				else
				{
					instance.setValue(attIndex++, stringValue);
				}
				
				instances.add(instance);
			}
		}
		return instances;
		
	}
	
	/**
	 * @deprecated
	 * @param input
	 * @return
	 */
	public static Instances getAsTimeSeriesDataFromList(List<Double> input){
		
		ArrayList<Attribute> attributes = new ArrayList<Attribute>();
		final Attribute data = new Attribute(Constants.TIME_SERIES_DATA_ATTRIB);
		attributes.add(data);
		
		Instances inst = new Instances(Constants.TIME_SERIES_RELATION_NAME, attributes, input.size());
		Instance each = null;
		
		for (Double d : input) {
			
			each = new SparseInstance(1);
			each.setValue(data, d);
			inst.add(each);
		}
		
		return inst;
		
	}
	
	public static Instance getAsNextTimeSeriesData(Instance last, double dataValue){
		
		Instance next = new SparseInstance(2);
		next.setValue(0, dataValue);
		next.setValue(1, ForecastingUtil.getNextDateAsDouble(last.value(1)));
		
		return next;
		
	}
	/**
	 * 
	 * @param input
	 * @param useTimestamp
	 * @return
	 */
	public static Instances getAsTimeSeriesData(List<TimeseriesParam> input, boolean useTimestamp){
		
		ArrayList<Attribute> attributes = new ArrayList<Attribute>();
		Attribute data = new Attribute(Constants.TIME_SERIES_DATA_ATTRIB);
		attributes.add(data);
		if (useTimestamp)
		{
			data = new Attribute(Constants.TIME_SERIES_DATETIME_ATTRIB);
			attributes.add(data);
		}
		Instances inst = new Instances(Constants.TIME_SERIES_RELATION_NAME, attributes, input.size());
		Instance each = null;
		
		for (TimeseriesParam tp : input) {
			
			if (useTimestamp)
			{
				each = new SparseInstance(2);
				each.setValue(attributes.get(0), tp.getValue());
				each.setValue(attributes.get(1), tp.getTimestamp().getTime());
				inst.add(each);
			}
			else
			{
				each = new SparseInstance(1);
				each.setValue(attributes.get(0), tp.getValue());
				inst.add(each);
			}
		}
		
		return inst;
		
	}
		

}
